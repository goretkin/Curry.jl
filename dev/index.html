<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FixArgs.jl</title><link rel="canonical" href="https://goretkin.gitlab.io/FixArgs.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FixArgs.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Examples-of-Base.Fix2"><span>Examples of <code>Base.Fix2</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Symbolic-computation-and-lazy-evaluation"><span>Symbolic computation and lazy evaluation</span></a></li><li><a class="tocitem" href="#Base.Iterators"><span><code>Base.Iterators</code></span></a></li><li><a class="tocitem" href="#Base.Rational"><span><code>Base.Rational</code></span></a></li><li><a class="tocitem" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments"><span>Fixed-Point Numbers and &quot;static&quot; arguments</span></a></li><li><a class="tocitem" href="#Pure-imaginary-type-and-Base.Complex"><span>Pure-imaginary type and <code>Base.Complex</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/goretkin/FixArgs.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FixArgs.jl"><a class="docs-heading-anchor" href="#FixArgs.jl">FixArgs.jl</a><a id="FixArgs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FixArgs.jl" title="Permalink"></a></h1><ul><li><a href="#FixArgs.jl">FixArgs.jl</a></li><li><a href="#Introduction">Introduction</a></li><ul><li><a href="#Examples-of-Base.Fix2">Examples of <code>Base.Fix2</code></a></li></ul><li><a href="#Symbolic-computation-and-lazy-evaluation">Symbolic computation and lazy evaluation</a></li><ul><li><a href="#Base.Iterators"><code>Base.Iterators</code></a></li><li><a href="#Base.Rational"><code>Base.Rational</code></a></li><li><a href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments">Fixed-Point Numbers and &quot;static&quot; arguments</a></li><li><a href="#Pure-imaginary-type-and-Base.Complex">Pure-imaginary type and <code>Base.Complex</code></a></li></ul></ul><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This package began as an exploration in generalizing <code>Base.Fix1</code> and <code>Base.Fix2</code>. These types are ways to represent a particular forms of anonymous functions. Let&#39;s illustrate. We&#39;ll use the <code>string</code> function in <code>Base</code>, which concatenates the string representations of its arguments:</p><pre><code class="language-julia-repl">julia&gt; string(&quot;first &quot;, &quot;second&quot;)
&quot;first second&quot;</code></pre><p>Now, to construct and use the <code>Fix1</code> and <code>Fix2</code> types:</p><pre><code class="language-julia-repl">julia&gt; using Base: Fix1, Fix2

julia&gt; f1 = Fix1(string, &quot;one then &quot;)
(::Base.Fix1{typeof(string),String}) (generic function with 1 method)

julia&gt; f1(&quot;two&quot;)
&quot;one then two&quot;</code></pre><p>The function-call behavior of <code>Fix1(f, bind)</code> is the same as <code>x -&gt; f(bind, x)</code>.</p><p>Similarly,</p><pre><code class="language-julia-repl">julia&gt; f2 = Fix2(string, &quot; before two&quot;)
(::Base.Fix2{typeof(string),String}) (generic function with 1 method)

julia&gt; f2(&quot;one&quot;)
&quot;one before two&quot;</code></pre><p>The function-call behavior of <code>Fix2(f, bind)</code> is the same as <code>x -&gt; f(x, bind)</code>.</p><p>The key point of the <code>Fix1</code> and <code>Fix2</code> types is that methods can dispatch on</p><ol><li>the type of <code>f</code></li><li>the type of <code>bind</code></li><li>the position of <code>bind</code> within the function call</li></ol><p>Dispatch is not tenable with anonymous functions. Let&#39;s illustrate while moving to a more practical example using <code>==</code> instead of <code>string</code>.</p><pre><code class="language-julia-repl">julia&gt; f1 = x -&gt; x == 0
#1 (generic function with 1 method)

julia&gt; f2 = Fix1(==, 0)
(::Base.Fix1{typeof(==),Int64}) (generic function with 1 method)</code></pre><p>Now define the &quot;same&quot; things again:</p><pre><code class="language-julia-repl">julia&gt; f3 = x -&gt; x == 0
#3 (generic function with 1 method)

julia&gt; f4 = Fix1(==, 0)
(::Base.Fix1{typeof(==),Int64}) (generic function with 1 method)</code></pre><p>The types of both the <code>Fix1</code> values is the same:</p><pre><code class="language-julia-repl">julia&gt; typeof(f2) === typeof(f4)
true</code></pre><p>But each anonymous function definition introduces a new type with an opaque name:</p><pre><code class="language-julia-repl">julia&gt; typeof(f1), typeof(f3)
(Main.ex-BaseFix.var&quot;#1#2&quot;, Main.ex-BaseFix.var&quot;#3#4&quot;)</code></pre><p>A new anonymous function is always given a unique type, which allows methods to specialize on the specific anonymous function passed as an argument, but does not &quot;permit&quot; dispatch. To be more accurate, as far as dispatch is concerned, the type of anonymous functions is not special:</p><pre><code class="language-julia-repl">julia&gt; foo(::typeof(f1)) = &quot;f1&quot;
foo (generic function with 1 method)

julia&gt; foo(::typeof(f3)) = &quot;f3&quot;
foo (generic function with 2 methods)

julia&gt; foo(f1)
&quot;f1&quot;

julia&gt; foo(f3)
&quot;f3&quot;</code></pre><p>But really we&#39;d like to use a type that is less opaque and furthermore is &quot;structural&quot; in some ways, rather than purely &quot;nominal&quot;.</p><h2 id="Examples-of-Base.Fix2"><a class="docs-heading-anchor" href="#Examples-of-Base.Fix2">Examples of <code>Base.Fix2</code></a><a id="Examples-of-Base.Fix2-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-of-Base.Fix2" title="Permalink"></a></h2><p>Where is it useful to dispatch on these special functions? Because <code>Base</code> <a href="https://github.com/JuliaLang/julia/issues/36554">does not export</a> and <a href="https://github.com/JuliaLang/julia/pull/36094">does not document</a> these types, there aren&#39;t methods <a href="https://juliahub.com/ui/RepoSearch?q=%3A%3A%28Base%5C.%29%3FFix%5B12%5D&amp;r=true">in the Julia ecosystem</a>.</p><p>But these types are constructed with, for example, <code>==(3)</code> or <code>in([1, 2, 3])</code>. A type like these is useful as a predicate to pass to higher-order functions, e.g. <code>findfirst(==(3), some_array)</code> to find the first element that equals <code>3</code>. Brevity asside, these types are useful to define more efficient methods of generic higher-order functions. For example, take <a href="https://github.com/JuliaLang/julia/blob/1f9e8bdbcf0ded6f1386f9329a284366dbb56120/base/array.jl#L1878-L1879">a specific method of the <code>findfirst</code> function</a>:</p><pre><code class="language-julia">findfirst(p::Union{Fix2{typeof(isequal),Int},Fix2{typeof(==),Int}}, r::OneTo{Int}) =
    1 &lt;= p.x &lt;= r.stop ? p.x : nothing</code></pre><p>The fallback for <code>findfirst</code> (triggered by e.g. <code>findfirst(x-&gt;x==3, 1:10)</code> instead of <code>findfirst(==(3), 1:10)</code>) would produce the same (correct) answer, but the method above will be quicker.</p><p>Dispatching on the <em>structure</em> of the predicate function enables a certain form of symbolic computation.</p><h1 id="Symbolic-computation-and-lazy-evaluation"><a class="docs-heading-anchor" href="#Symbolic-computation-and-lazy-evaluation">Symbolic computation and lazy evaluation</a><a id="Symbolic-computation-and-lazy-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-computation-and-lazy-evaluation" title="Permalink"></a></h1><p>This package provides a generalization of <code>Fix1</code> and <code>Fix2</code> in a few ways:</p><ol><li>A function of any positional arity can be used, and any number of its arguments can be bound, allowing the remaining arguments to be provided later.</li><li>A function can have its keyword arguments bound.</li><li>The function <code>x -&gt; f(x, b)</code> is represented with types:<ul><li>a <a href="@ref"><code>Lambda</code></a> to represent function (<code>args -&gt; body</code>)</li><li>a <a href="@ref"><code>Call</code></a> to represent the function <em>call</em> (<code>f(...)</code>) in the body</li><li>a <a href="@ref"><code>ArgPos</code></a> to represent the <code>x</code> in the body of the lambda function</li></ul></li></ol><p>The third generalization is powerful, because it&#39;s effectively the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>.</p><p>It is worth considering first just <a href="@ref"><code>Call</code></a>, which can serve the purpose of representing a <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">delayed function call evaluation</a>. If you prefer, you may also consider a <a href="https://en.wikipedia.org/wiki/Thunk">thunk</a> <code>() -&gt; foo(1, 2)</code>, which would be a <code>Lambda</code> (with no arguments) <em>and</em> a <code>Call</code> that does not mention any &quot;free variables&quot;.</p><p>If laziness is all that is needed, then defining a Julia anonymous function will do the job. But this package allows an additional benefit since methods can dispatch on details of the lazy call.</p><p>In many domains, new types are introduced to represent this pattern.</p><h2 id="Base.Iterators"><a class="docs-heading-anchor" href="#Base.Iterators"><code>Base.Iterators</code></a><a id="Base.Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Base.Iterators" title="Permalink"></a></h2><p><code>Base.Generator</code> consists of two fields <code>f</code> and <code>iter</code>. This can be taken as a representation of <code>map(f, iter)</code>:</p><pre><code class="language-julia-repl">julia&gt; using FixArgs

julia&gt; gen = let f = string, iter = 1:10
           @xquote map(f, iter)
       end
Call(Some(map), FrankenTuple((Some(string), Some(1:10)), NamedTuple()))</code></pre><p>It&#39;s certainly less nice to look at than <code>Base.Generator{UnitRange{Int64}, typeof(string)}(string, 1:10)</code>. Better UX / ergonomics are be possible by defining a type alias:</p><pre><code class="language-julia">const MyGenerator{F, I} = FixArgs.Call{Some{typeof(map)}, FixArgs.FrankenTuples.FrankenTuple{Tuple{Some{F}, Some{I}, (), Tuple{}}}</code></pre><p>That is quite unsightly, and there are quite a few internals leaking out. We can use a macro instead:</p><pre><code class="language-julia-repl">julia&gt; const MyGenerator{F, I} = @xquoteT map(::F, ::I)
FixArgs.Call{Some{typeof(map)},FrankenTuples.FrankenTuple{Tuple{Some{F},Some{I}},(),Tuple{}}} where I where F</code></pre><p>It should be made convenient to defining constructors and <code>show</code> methods that correspond with the type alias.</p><p>To evaluate the call (i.e. &quot;collect the iterator&quot;):</p><pre><code class="language-julia-repl">julia&gt; xeval(gen)
10-element Array{String,1}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;
 &quot;4&quot;
 &quot;5&quot;
 &quot;6&quot;
 &quot;7&quot;
 &quot;8&quot;
 &quot;9&quot;
 &quot;10&quot;</code></pre><p>This example is actually circular. The evaluation of the <code>map</code> call is done in terms of <code>Generator</code>! The <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/abstractarray.jl#L2328">definition</a>:</p><pre><code class="language-julia">map(f, A) = collect(Generator(f,A))</code></pre><p>Breaking this circularity is possible by defining</p><pre><code class="language-julia">function iterate(gen::(@xquoteT map(::F, ::I))) where F, I
    f = FixArgs.xeval(gen.args[1])  # not the prettiest thing right now...
    iter = FixArgs.xeval(gen.args[2])
    # ...
end</code></pre><p>and might also require a separation of the purposes of <code>collect</code> and <code>map</code>. See <a href="https://github.com/JuliaLang/julia/issues/39628">this issue</a>.</p><p>Many types in <code>Base.Iterators</code> can be seen as lazy calls of existing functions. <code>Base.Iterators.Filter(flt, itr)</code> could be replaced with <code>@xquote filter(flt, itr)</code>. And the dispatches done on these types to enable the existing symbolic computation, <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/iterators.jl#L463">e.g.</a>:</p><pre><code class="language-julia">reverse(f::Filter) = Filter(f.flt, reverse(f.itr))</code></pre><p><code>Base.Iterators.Flatten</code>, which <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/iterators.jl#L463">defines a convenience function</a></p><pre><code class="language-julia">flatten(itr) = Flatten(itr)</code></pre><p><em>could</em> be written in terms of a function <code>flatten</code> with no methods. However, it is perhaps better seen as <code>@xquote reduce(vcat, it)</code></p><h2 id="Base.Rational"><a class="docs-heading-anchor" href="#Base.Rational"><code>Base.Rational</code></a><a id="Base.Rational-1"></a><a class="docs-heading-anchor-permalink" href="#Base.Rational" title="Permalink"></a></h2><p>What is <code>Rational</code> but lazy division on integers?</p><pre><code class="language-julia">julia&gt; 1/9 * 3/2 # eager division
0.16666666666666666</code></pre><pre><code class="language-julia-repl">julia&gt; using FixArgs

julia&gt; (@xquote 1/9) * (@xquote 3/2)
ERROR: MethodError: no method matching *(::FixArgs.Call{Some{typeof(/)},FrankenTuples.FrankenTuple{Tuple{Some{Int64},Some{Int64}},(),Tuple{}}}, ::FixArgs.Call{Some{typeof(/)},FrankenTuples.FrankenTuple{Tuple{Some{Int64},Some{Int64}},(),Tuple{}}})
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538</code></pre><p>Of course, we have to do some more work.</p><pre><code class="language-julia">using Base: divgcd

function Base.:*(
        x::(@xquoteT ::T / ::T),
        y::(@xquoteT ::T / ::T),
        ) where {T}
    xn, yd = divgcd(something(x.args[1]), something(y.args[2]))
    xd, yn = divgcd(something(x.args[2]), something(y.args[1]))
    ret = @xquote $(xn * yn) / $(xd * yd) # TODO use `unsafe_rational` and `checked_mul`
    ret
end</code></pre><p>Now, try again:</p><pre><code class="language-julia-repl">julia&gt; q = (@xquote 1/9) * (@xquote 3/2)
Call(Some(/), FrankenTuple((Some(1), Some(6)), NamedTuple()))

julia&gt; map(xeval, q.args) # make numerator and denominator plainly visible
ERROR: MethodError: no method matching xeval(::Some{Int64})
Closest candidates are:
  xeval(::Some, !Matched::FixArgs.Context) at /home/runner/work/FixArgs.jl/FixArgs.jl/src/eval.jl:17
  xeval(::Some, !Matched::Nothing) at /home/runner/work/FixArgs.jl/FixArgs.jl/src/eval.jl:18
  xeval(!Matched::FixArgs.ArgPos{i}, !Matched::FixArgs.Context{Nothing,P}) where {i, P} at /home/runner/work/FixArgs.jl/FixArgs.jl/src/eval.jl:13
  ...</code></pre><p>compare with using <code>//</code> to construct a <code>Base.Rational</code>:</p><pre><code class="language-julia-repl">julia&gt; 1//9 * 3//2
1//6</code></pre><p>Finally, because we have encoded the relationship between this &quot;new&quot; rational type, and <code>/</code>, we can do:</p><pre><code class="language-julia-repl">julia&gt; xeval(q)
0.16666666666666666</code></pre><p>We could define an alias:</p><pre><code class="language-julia">const MyRational{T} = @xquoteT(::T / ::T)</code></pre><pre class="documenter-example-output">FixArgs.Call{Some{typeof(/)},FrankenTuples.FrankenTuple{Tuple{Some{T},Some{T}},(),Tuple{}}} where T</pre><p>which would also enforce the same type for both the numerator and denominator, as is the case of <code>Base.Rational</code>.</p><pre><code class="language-julia-repl">julia&gt; sizeof(MyRational{Int32})
8</code></pre><p>Occasionally, a user might find this to be a limitation, yet they would still like to use some of the generic algorithms that might apply.</p><p>The fields of <code>Base.Rational</code> are <code>num</code> and <code>den</code>. They have to be named since that&#39;s all that gives the fields any meaning at all. In our type, however, instead of naming the fields they can be distinguished by the role they play with respect to the <code>/</code> function.</p><h2 id="Fixed-Point-Numbers-and-&quot;static&quot;-arguments"><a class="docs-heading-anchor" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments">Fixed-Point Numbers and &quot;static&quot; arguments</a><a id="Fixed-Point-Numbers-and-&quot;static&quot;-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments" title="Permalink"></a></h2><p>A fixed-point number is just a rational number with a specified denominator. If we have a large array of fixed-point numbers with the same denominator, we certainly do not want to store the denominator repeatedly.</p><p>And we want to ensure constant propagation happens, too.</p><p>So we can &quot;bake in&quot; some values (<code>Base.isbitstype</code>) into the type of <code>Call</code> itself!</p><p>In other words, what is a fixed-point number but lazy division with a static denominator? Here is an example that models <code>Fixed{Int8,7}</code> from <a href="https://github.com/JuliaMath/FixedPointNumbers.jl"><code>FixedPointNumbers.jl</code></a>. The macros use the notation <code>V::::S</code> to mark an argument <code>V</code> as &quot;static&quot;. Also note the use of <code>$</code> to escape subexpressions.</p><pre><code class="language-julia-repl">julia&gt; using FixArgs



julia&gt; MyFixed{Int8, 128} === typeof(MyQ0f7(3))
true

julia&gt; function Base.:+(a::MyFixed{N,D}, b::MyFixed{N,D})::MyFixed{N,D} where {N, D}
           n = something(a.args[1]) + something(b.args[1])
           return (@xquote $(N(n)) / D::::S)
       end

julia&gt; xeval(MyQ0f7(3) + MyQ0f7(2)) === 5/128
true</code></pre><pre><code class="language-julia-repl">julia&gt; sizeof(MyFixed)
ERROR: Argument is an incomplete Call type and does not have a definite size.

julia&gt; sizeof(Int8)
1</code></pre><p>And the generated code appears to be equivalent between</p><pre><code class="language-julia">using FixedPointNumbers
look_inside_1(x, y) = reinterpret(Fixed{Int8, 7}, Int8(x)) + reinterpret(Fixed{Int8, 7}, Int8(y))</code></pre><p>and</p><pre><code class="language-julia">look_inside_2(x, y) = MyQ0f7(x) + MyQ0f7(y)</code></pre><h2 id="Pure-imaginary-type-and-Base.Complex"><a class="docs-heading-anchor" href="#Pure-imaginary-type-and-Base.Complex">Pure-imaginary type and <code>Base.Complex</code></a><a id="Pure-imaginary-type-and-Base.Complex-1"></a><a class="docs-heading-anchor-permalink" href="#Pure-imaginary-type-and-Base.Complex" title="Permalink"></a></h2><p>Now that we can make some arguments static, we can introduce a meaningful example where the lazy call might not be valid to begin with. You can define a type such that <code>xeval</code> raises <code>MethodError</code> and still represent the computation symbolically. The Julia ecosystem goes to great lengths to find the right generic functions and to ensure that all methods defined on generic functions are semantically compatible. This effort enables generic programming and interoperability. You can define a type <code>A</code> in terms of a function <code>f</code> and a type <code>B</code> even if it may not make sense to define a new method of <code>f</code> on <code>B</code>.</p><p>Here is an over-the-top example:</p><pre><code class="language-julia-repl">julia&gt; using FixArgs

julia&gt; struct ImaginaryUnit end    # if we want to be really cute, can do `@xquote sqrt((-1)::::S)`

julia&gt; const Imaginary{T} = @xquoteT ::T * ::ImaginaryUnit
FixArgs.Call{Some{typeof(*)},FrankenTuples.FrankenTuple{Tuple{Some{T},Some{Main.ex-Imaginary.ImaginaryUnit}},(),Tuple{}}} where T

julia&gt; Imaginary(x) = @xquote x * $(ImaginaryUnit())   # note escaping
FixArgs.Call{Some{typeof(*)},FrankenTuples.FrankenTuple{Tuple{Some{T},Some{Main.ex-Imaginary.ImaginaryUnit}},(),Tuple{}}} where T</code></pre><p>note that if we assume we have no <code>Base.Complex</code> or anything like it, we don&#39;t have a way to further evaluate:</p><pre><code class="language-julia-repl">julia&gt; xeval(Imaginary(3))
ERROR: MethodError: no method matching *(::Int64, ::Main.ex-Imaginary.ImaginaryUnit)
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538
  *(::T, !Matched::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:87
  *(::Union{Int16, Int32, Int64, Int8}, !Matched::BigInt) at gmp.jl:538
  ...</code></pre><p>We represented pure imaginary numbers as lazy multiplication of numbers and a singleton type <code>ImaginaryUnit</code>, and it is basically as if we had defined</p><pre><code class="language-none">struct Imaginary{T}
    _::T
end</code></pre><p>Let&#39;s just go ahead and represent complex numbers too:</p><pre><code class="language-julia-repl">julia&gt; # const MyComplex{R, I} = @xquoteT ::R + (::I * ::ImaginaryUnit) # TODO this macro doesn&#39;t work
       MyComplex(r, i) = @xquote r + i * $(ImaginaryUnit())
MyComplex (generic function with 1 method)</code></pre><p>Note this monster of a type has the same size as <code>Base.Complex</code>:</p><pre><code class="language-julia-repl">julia&gt; sizeof(Complex(1, 2))
16

julia&gt; sizeof(MyComplex(1, 2))
16</code></pre><p>and layout too:</p><pre><code class="language-julia-repl">julia&gt; reinterpret(Int64, [Complex(1, 2)])
2-element reinterpret(Int64, ::Array{Complex{Int64},1}):
 1
 2

julia&gt; reinterpret(Int64, [MyComplex(1, 2)])
2-element reinterpret(Int64, ::Array{FixArgs.Call{Some{typeof(+)},FrankenTuples.FrankenTuple{Tuple{Some{Int64},FixArgs.Call{Some{typeof(*)},FrankenTuples.FrankenTuple{Tuple{Some{Int64},Some{Main.ex-Imaginary.ImaginaryUnit}},(),Tuple{}}}},(),Tuple{}}},1}):
 1
 2</code></pre><p>Of course, there are many different types that would all be mathematically equivalent by swapping the arguments to <code>+</code> or <code>*</code>. Note that swapping the arguments to <code>+</code> would give a different memory layout.</p><article class="docstring"><header><a class="docstring-binding" id="FixArgs.ArgPos" href="#FixArgs.ArgPos"><code>FixArgs.ArgPos</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Within the <code>body</code> of a <a href="#FixArgs.Lambda"><code>Lambda</code></a>, represent a formal positional parameter of that<a href="#FixArgs.Lambda"><code>Lambda</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/types.jl#LL20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Arity" href="#FixArgs.Arity"><code>FixArgs.Arity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent the <a href="https://en.wikipedia.org/wiki/Arity">arity</a> of a <a href="#FixArgs.Lambda"><code>Lambda</code></a>.</p><p>Currently, only represents a fixed number of positional arguments, but may be generalized to include optional and keyword arguments.</p><p><code>P</code> is 0, 1, 2, ... <code>KW</code> is always <code>NoKeywordArguments</code>, and may be extended in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/types.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Call" href="#FixArgs.Call"><code>FixArgs.Call</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A call &quot;f(args...)&quot;. <code>args</code> may represent both positional and keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/types.jl#LL52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Context" href="#FixArgs.Context"><code>FixArgs.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>terms are evaluated with respect to a <code>Context</code> A <code>Context</code> is an associations between bound variables and values, and they may be nested (via the <code>parent</code> field).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/eval.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Lambda" href="#FixArgs.Lambda"><code>FixArgs.Lambda</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A lambda expression &quot;args -&gt; body&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/types.jl#LL44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.ParentScope" href="#FixArgs.ParentScope"><code>FixArgs.ParentScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nest <a href="#FixArgs.ArgPos"><code>ArgPos</code></a> in <a href="#FixArgs.ParentScope"><code>ParentScope</code></a>s to represent a reference to the formal parameters of a &quot;parent&quot; function. Forms a unary representation.</p><p>Related: [De Bruijn indices]https://en.wikipedia.org/wiki/De<em>Bruijn</em>index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/types.jl#LL28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.TypedExpr" href="#FixArgs.TypedExpr"><code>FixArgs.TypedExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Roughly mirror <code>Base.Expr</code>, except that the the head of the expression (encoded in the <code>head</code> field) can be dispatched on.</p><p>This is only used in an intermediate representation of this package.</p><p>Note that <code>Expr</code> and <code>TypedExpr</code> are constructed slightly differently. Each argument of an <code>Expr</code> is an argument to <code>Expr</code>, whereas all arguments of a <code>TypedExpr</code> are passed as one argument (a tuple) to <code>TypedExpr</code></p><p>e.g.</p><p><code>Expr(:call, +, 1, 2)</code> corresponds to <code>TypedExpr(Val{:call}(), (+, 1, 2))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/TypedExpressions.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.isexpr-Tuple{Expr}" href="#FixArgs.isexpr-Tuple{Expr}"><code>FixArgs.isexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isexpr(expr) -&gt; Bool
isexpr(expr, head) -&gt; Bool</code></pre><p>Checks whether given value isa <code>Base.Expr</code> and if further given <code>head</code>, it also checks whether the <code>head</code> matches <code>expr.head</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using ExprParsers
julia&gt; EP.isexpr(:(a = hi))
true
julia&gt; EP.isexpr(12)
false
julia&gt; EP.isexpr(:(f(a) = a), :(=))
true
julia&gt; EP.isexpr(:(f(a) = a), :function)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/expr.jl#LL82-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.lc_expr-Tuple{Any}" href="#FixArgs.lc_expr-Tuple{Any}"><code>FixArgs.lc_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a <code>::TypedExpr</code> to a Lambda-Call expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/TypedExpressions.jl#LL58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.normalize_lambda_1_arg-Tuple{Any}" href="#FixArgs.normalize_lambda_1_arg-Tuple{Any}"><code>FixArgs.normalize_lambda_1_arg</code></a> — <span class="docstring-category">Method</span></header><section><div><p>normalize <code>:(x -&gt; body)</code> into  <code>:((x,) -&gt; body</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/parse.jl#LL14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.postwalk-Tuple{Any,Any}" href="#FixArgs.postwalk-Tuple{Any,Any}"><code>FixArgs.postwalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">postwalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>after</em> they have been transformed by the walk.</p><p>See also: <a href="#FixArgs.prewalk-Tuple{Any,Any,Any}"><code>prewalk</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/expr.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.prewalk-Tuple{Any,Any,Any}" href="#FixArgs.prewalk-Tuple{Any,Any,Any}"><code>FixArgs.prewalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prewalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>before</em> they have been transformed by the walk, and the walk will be applied to whatever <code>f</code> returns.</p><p>This makes <code>prewalk</code> somewhat prone to infinite loops; you probably want to try <a href="#FixArgs.postwalk-Tuple{Any,Any}"><code>postwalk</code></a> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/expr.jl#LL17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.relabel_args" href="#FixArgs.relabel_args"><code>FixArgs.relabel_args</code></a> — <span class="docstring-category">Function</span></header><section><div><p>α-conversion in λ-calculus</p><p><code>labeler(x)</code> produces a <code>Symbol</code> or similar from <code>x.referent_depth</code> <code>x.antecedent_depth</code> <code>x.arg_i</code> <code>x.sym</code> – name before relabeling</p><p><code>x.referent_depth - x.antecedent_depth</code> is number of <code>-&gt;</code>s that are between the evaluation site and the definition site</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/parse.jl#LL48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.uneval-Tuple{Expr}" href="#FixArgs.uneval-Tuple{Expr}"><code>FixArgs.uneval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a value, produce an expression that when <code>eval</code>&#39;d produces the value.</p><p>e.g.</p><pre><code class="language-julia">julia&gt; eval(uneval(Expr(:my_call, :arg1, :arg2)))
:($(Expr(:my_call, :arg1, :arg2)))

julia&gt; eval(eval(uneval(:(sqrt(9)))))
3.0</code></pre><p>This function is used to return expressions from this package&#39;s macros. This is likely not a well-posed problem to begin with. <a href="https://github.com/JuliaLang/julia/issues/33260">Related issue.</a></p><p>Note the special case for <code>:(esc(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/uneval.jl#LL1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.xapply" href="#FixArgs.xapply"><code>FixArgs.xapply</code></a> — <span class="docstring-category">Function</span></header><section><div><p>apply a <a href="#FixArgs.Lambda"><code>Lambda</code></a> expression to arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/eval.jl#LL91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.xeval-Tuple{FixArgs.Call}" href="#FixArgs.xeval-Tuple{FixArgs.Call}"><code>FixArgs.xeval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate a Lambda-Call expression</p><p>Currently only works on <a href="#FixArgs.Call"><code>Call</code></a> expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/eval.jl#LL74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@fix-Tuple{Any}" href="#FixArgs.@fix-Tuple{Any}"><code>FixArgs.@fix</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>A convenience macro that implements the syntax of <a href="https://github.com/JuliaLang/julia/pull/24990">this PR</a></p><p><code>@fix f(_, b)</code> is the equivalent of <code>x -&gt; f(x, b)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/ergonomics.jl#LL249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@quote_some-Tuple{Any}" href="#FixArgs.@quote_some-Tuple{Any}"><code>FixArgs.@quote_some</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>This macro is used to debug and introspect the escaping behavior of <a href="#FixArgs.@xquote-Tuple{Any}"><code>@xquote</code></a></p><pre><code class="language-julia">julia&gt; dump(let x = 9
       @xquote sqrt(x)
       end)
Expr
    head: Symbol call
    args: Array{Any}((2,))
        1: sqrt (function of type typeof(sqrt))
        2: Int64 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/ergonomics.jl#LL144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@xquote-Tuple{Any}" href="#FixArgs.@xquote-Tuple{Any}"><code>FixArgs.@xquote</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Transform julia syntax into a <a href="#FixArgs.Lambda"><code>Lambda</code></a>-<a href="#FixArgs.Call"><code>Call</code></a> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/ergonomics.jl#LL180-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@xquoteT-Tuple{Any}" href="#FixArgs.@xquoteT-Tuple{Any}"><code>FixArgs.@xquoteT</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>The types produced by this package are unwieldly. This macro permits a convenient syntax, e.g. <code>@xquoteT func(::Arg1Type, ::Arg2Type)</code> to represent types.</p><pre><code class="language-julia">let func = identity, arg = 1
    typeof(@xquote func(arg)) == @xquoteT func(::typeof(arg))
end

# output

true</code></pre><p>If an argument is &quot;static&quot;, then it is part of the type, and the value is annotated as illustrated:</p><pre><code class="language-julia">@xquoteT string(123::::S)

# output

FixArgs.Call{Some{typeof(string)},FrankenTuples.FrankenTuple{Tuple{Val{123}},(),Tuple{}}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/02cfa1baa940e15084553e6e26020a4f7a233d00/src/ergonomics.jl#LL277-L301">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 February 2021 07:09">Tuesday 16 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
